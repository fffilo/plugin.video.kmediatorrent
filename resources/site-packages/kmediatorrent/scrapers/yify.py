from kmediatorrent import plugin
from kmediatorrent.scrapers import scraper
from kmediatorrent.ga import tracked
from kmediatorrent.caching import cached_route
from kmediatorrent.utils import ensure_fanart
from kmediatorrent.library import library_context


BASE_URL = "%s/" % plugin.get_setting("base_yify")
HEADERS = {
    "Referer": BASE_URL,
}
MAGNET_URL = "magnet:?xt=urn:btih:%s&dn=%s&tr=udp://open.demonii.com:1337/announce&tr=udp://tracker.openbittorrent.com:80&tr=udp://tracker.coppersurfer.tk:6969&tr=udp://glotorrents.pw:6969/announce&tr=udp://tracker.opentrackr.org:1337/announce&tr=udp://torrent.gresille.org:80/announce&tr=udp://p4p.arenabg.com:1337&tr=udp://tracker.leechers-paradise.org"
YOUTUBE_ACTION = "plugin://plugin.video.youtube/?path=/root/video&action=play_video&videoid=%s"
MOVIES_PER_PAGE = 20
GENRES = [
    "Action",
    "Adventure",
    "Animation",
    "Biography",
    "Comedy",
    "Crime",
    "Documentary",
    "Drama",
    "Family",
    "Fantasy",
    "Film-Noir",
    "Game-Show",
    "History",
    "Horror",
    "Music",
    "Musical",
    "Mystery",
    "News",
    "Reality-TV",
    "Romance",
    "Sci-Fi",
    "Sport",
    "Talk-Show",
    "Thriller",
    "War",
    "Western",
]
# Cache TTLs
DEFAULT_TTL = 24 * 3600 # 24 hours


@scraper("%s"%str(plugin.get_setting("yify_label")), "%s"%str(plugin.get_setting("yify_picture")))
@plugin.route("/yify")
@ensure_fanart
@tracked
def yify_index():
    return [
        {"label": "Search", "path": plugin.url_for("yify_search")},
        {"label": "Browse by Genre", "path": plugin.url_for("yify_genres")},

        {"label": "Most Popular", "path": plugin.url_for("yify_movies", sort_by="seeds", order_by="desc", quality="all", page=1, limit=MOVIES_PER_PAGE)},
        {"label": "    in 720p", "path": plugin.url_for("yify_movies", sort_by="seeds", order_by="desc", quality="720p", page=1, limit=MOVIES_PER_PAGE)},
        {"label": "    in 1080p", "path": plugin.url_for("yify_movies", sort_by="seeds", order_by="desc", quality="1080p", page=1, limit=MOVIES_PER_PAGE)},
        {"label": "    in 3D", "path": plugin.url_for("yify_movies", sort_by="seeds", order_by="desc", quality="3D", page=1, limit=MOVIES_PER_PAGE)},

        {"label": "Best Rated", "path": plugin.url_for("yify_movies", sort_by="rating", order_by="desc", quality="all", page=1, limit=MOVIES_PER_PAGE)},
        {"label": "    in 720p", "path": plugin.url_for("yify_movies", sort_by="rating", order_by="desc", quality="720p", page=1, limit=MOVIES_PER_PAGE)},
        {"label": "    in 1080p", "path": plugin.url_for("yify_movies", sort_by="rating", order_by="desc", quality="1080p", page=1, limit=MOVIES_PER_PAGE)},
        {"label": "    in 3D", "path": plugin.url_for("yify_movies", sort_by="rating", order_by="desc", quality="3D", page=1, limit=MOVIES_PER_PAGE)},

        {"label": "Most Recent", "path": plugin.url_for("yify_movies", sort_by="date_added", order_by="desc", quality="all", page=1, limit=MOVIES_PER_PAGE)},
        {"label": "    in 720p", "path": plugin.url_for("yify_movies", sort_by="date_added", order_by="desc", quality="720p", page=1, limit=MOVIES_PER_PAGE)},
        {"label": "    in 1080p", "path": plugin.url_for("yify_movies", sort_by="date_added", order_by="desc", quality="1080p", page=1, limit=MOVIES_PER_PAGE)},
        {"label": "    in 3D", "path": plugin.url_for("yify_movies", sort_by="date_added", order_by="desc", quality="3D", page=1, limit=MOVIES_PER_PAGE)},
    ]


@library_context
def yify_show_data(callback):
    import xbmc
    import xbmcgui
    from contextlib import nested, closing
    from itertools import izip, chain
    from concurrent import futures
    from urllib import quote_plus
    from kmediatorrent import tmdb
    from kmediatorrent.utils import url_get_json, terminating, SafeDialogProgress

    plugin.set_content("movies")
    args = dict((k, v[0]) for k, v in plugin.request.args.items())
    current_page = int(args["page"])
    limit = int(args["limit"])

    with closing(SafeDialogProgress(delay_close=0)) as dialog:
        dialog.create(plugin.name)
        dialog.update(percent=0, line1="Fetching movie information...", line2="", line3="")

        try:
            search_result = url_get_json("%s/api/v2/list_movies.json" % BASE_URL, params=args, headers=HEADERS).get("data")
        except:
            plugin.notify("Unable to connect to %s." % BASE_URL)
            raise
        movies = search_result.get("movies") or []

        if not movies:
            return

        state = {"done": 0}
        def on_movie(future):
            data = future.result()
            state["done"] += 1
            dialog.update(
                percent=int(state["done"] * 100.0 / len(movies)),
                line2=data.get("title") or data.get("MovieTitleClean") or "",
            )

        with futures.ThreadPoolExecutor(max_workers=2) as pool_tmdb:
            tmdb_list = [pool_tmdb.submit(tmdb.get, movie["imdb_code"]) for movie in movies]
            [future.add_done_callback(on_movie) for future in tmdb_list]
            while not all(job.done() for job in tmdb_list):
                if dialog.iscanceled():
                    return
                xbmc.sleep(100)

        tmdb_list = map(lambda job: job.result(), tmdb_list)
        for movie, tmdb_meta in izip(movies, tmdb_list):
            if tmdb_meta:
                for torrent in movie["torrents"]:
                    if args.get("quality") == "all" or args.get("quality") == torrent["quality"]:
                        item = tmdb.get_list_item(tmdb_meta)
                        item.update({
                            "path": plugin.url_for("play", uri=MAGNET_URL % (torrent["hash"], quote_plus(movie["title"].encode("utf8")))),
                            "is_playable": True,
                        })
                        item.setdefault("info", {}).update({
                            "count": movie["id"],
                            "genre": "%s (%s %s S:%s P:%s)" % (item["info"]["genre"], torrent["quality"], torrent["size"], torrent["seeds"], torrent["peers"]),
                            "plot_outline": tmdb_meta["overview"],
                            "video_codec": "h264",
                        })
                        stream_info = {
                            "video": {
                                "codec": "h264"
                            },
                            "audio": {
                                "codec": "aac"
                            }
                        }
                        if torrent["quality"] == "720p":
                            stream_info["video"]["width"] = 1280
                            stream_info["video"]["height"] = 720
                        elif torrent["quality"] == "1080p":
                            stream_info["video"]["width"] = 1920
                            stream_info["video"]["height"] = 1080
                        item.setdefault("stream_info", {}).update(stream_info)
                        yield item

        if current_page < (int(search_result["movie_count"]) / limit):
            next_args = args.copy()
            next_args["page"] = int(next_args["page"]) + 1
            yield {
                "label": ">> Next page",
                "path": plugin.url_for(callback, **next_args),
            }


@plugin.route("/yify/genres")
@ensure_fanart
@tracked
def yify_genres():
    for genre in GENRES:
        yield {
            "label": genre,
            "path": plugin.url_for("yify_genre", genre=genre, sort_by="seeds", order_by="desc", quality="all", page=1, limit=MOVIES_PER_PAGE),
        }


@plugin.route("/yify/genres/<genre>/<page>")
@cached_route(ttl=DEFAULT_TTL, content_type="movies")
@ensure_fanart
@tracked
def yify_genre(genre, page):
    plugin.request.args.update({
        "genre": [genre],
        "page": [page],
    })
    return yify_show_data("yify_genre")


@plugin.route("/yify/browse/<sort_by>/<quality>/<page>")
@cached_route(ttl=DEFAULT_TTL, content_type="movies")
@ensure_fanart
@tracked
def yify_movies(sort_by, quality, page):
    plugin.request.args.update({
        "sort_by": [sort_by],
        "quality": [quality],
        "page": [page],
    })
    return yify_show_data("yify_movies")


@plugin.route("/yify/search")
@tracked
def yify_search():
    query = plugin.request.args.get("query")
    if query:
        query = query[0]
    else:
        query = plugin.keyboard("", "kmediatorrent - YIFY - Search")
    if query:
        plugin.redirect(plugin.url_for("yify_search_query", query_term=query, quality="all", page=1, limit=MOVIES_PER_PAGE))


@plugin.route("/yify/search/<query_term>/<page>")
@cached_route(ttl=DEFAULT_TTL, content_type="movies")
@ensure_fanart
@tracked
def yify_search_query(query_term, page):
    plugin.request.args.update({
        "query_term": [query_term],
        "page": [page],
    })
    return yify_show_data("yify_search_query")
